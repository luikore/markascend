module Markascend
  LineUnit = Struct.new :env, :line, :block, :linenum
  # process a line with (maybe) a followed up indented block
  class LineUnit
    class << self
      attr_accessor :parsers
    end
    LineUnit.parsers = [
      :parse_inline_code,
      :parse_math,
      :parse_auto_link,
      :parse_macro,
      # link/bold/italic can contain char
      # but link need not interpolate with bold or italic, seems too rare cased
      :parse_link,
      # bold and italic can interpolate each other
      :parse_bold_italic,
      :parse_char
    ]

    def parse
      # block code
      if /^\|\ *(?!\d)(?<lang>\w+)\ *$/ =~ line
        # TODO hilite class
        return "<code class=\"code-#{lang}\">#{(CGI.escape_html block) if block}</code>"
      end

      @out = []
      @src = StringScanner.new line
      while LineUnit.parsers.any?{|p| send p}
      end
      @out.join
    end

    # the same as markdown
    def parse_inline_code
      if s = @src.scan(/
          (`{1,})(\ ?)
          .*?
          \2\1
        /x)
        s =~ /^
          (`{1,})(\ ?)
          (.*?)
          \2\1
        $/x
        # TODO assign inline color class
        @out << '<code>'
        @out << (CGI.escape_html $3)
        @out << '</code>'
        true
      end
    end

    # no escape chars, but \\ and \$ are treated as atomic parsing units
    def parse_math
      if (s = @src.scan /\$(?:\\[\\\$]|[^\$])*\$/)
        @out << '<code class="math">'
        @out << (CGI.escape_html s[1...-1])
        @out << '</code>'
        true
      end
    end

    def parse_auto_link
      # TODO make protocol configurable
      if (s = @src.scan /(https|http|ftp|mailto)\:\/\/\S+/)
        s.gsub! /"/, '\\"'
        @out << '<a href="#{s}">'
        @out << (CGI.escape_html s)
        @out << '</a>'
        true
      end
    end

    def parse_macro
      return unless macro = @src.scan(/\\(?!\d)\w+/)
      macro = macro[1..-1]
      block = scan_lexical_parens || scan_recursive_braces || self.block
      @out << Macro.new(macro, block).parse
      true
    end

    def parse_link
      pos = @src.pos
      return unless @src.scan(/\[/)

      footnode_kind = @src.scan(/[\.\:]/)
      content = ''
      loop do
        if res = @src.scan(/\]/)
          break
        elsif res = parse_char(false)
          content << res
        else
          # failed
          @src.pos = pos
          return
        end
      end

      case footnode_kind
      when '.'
      when ':'
      else
        if addr = scan_lexical_parens || scan_recursive_braces
          # TODO smarter addr to recognize things like a.b.com
          addr.gsub!(/[\\\"]/, '\\\1')
          @out << "<a href=\"#{addr}\">#{content}</a>"
          true
        else
          @src.pos = pos
          nil
        end
      end
    end

    def parse_bold_italic emit=true
      pos = @src.pos
      if s = @src.scan(/\*\*/)
        term = /\*\*/
        out = ['<b>']
        out_end = '</b>'
      elsif s = @src.scan(/\*/)
        term = /\*/
        out = ['<i>']
        out_end = '</i>'
      else
        return
      end

      loop do
        if res = @src.scan(/\\[\\\*]/)
          out << res[1]
        elsif @src.scan(term)
          out << out_end
          break
        elsif res = parse_bold_italic(false)
          out << res
        elsif res = parse_char(false)
          out << res
        else
          # failed
          @src.pos = pos
          return
        end
      end

      if emit
        @out << out.join
        true
      else
        out.join
      end
    end

    def parse_char emit=true
      # entity list generated by:
      # ruby -rregexp_optimized_union -e'puts Regexp.optimized_union($stdin.read.scan(/(?<=ENTITY )\w+/)).source' < tools/html4_entities.dtd
      # dtd from http://www.w3.org/TR/html4/sgml/entities.html
      if c = @src.scan(/
          &(?:
            n(?:bsp|ot|tilde)|i(?:excl|quest|grave|acute|circ|uml)|c(?:e(?:nt|dil)|urren|opy|cedil)|p(?:ound|lusmn|ara)|y(?:en|acute|uml)|brvbar|s(?:ect|hy|up[123]|zlig)|u(?:ml|grave|acute|circ|uml)|o(?:rd[fm]|grave|acute|circ|tilde|uml|slash)|laquo|r(?:eg|aquo)|m(?:acr|i(?:cro|ddot))|d(?:eg|ivide)|a(?:c(?:ute|irc)|grave|acute|tilde|uml|ring|elig)|frac(?:1[24]|34)|A(?:grave|acute|circ|tilde|uml|ring|Elig)|Ccedil|E(?:grave|acute|circ|uml|TH)|I(?:grave|acute|circ|uml)|Ntilde|O(?:grave|acute|circ|tilde|uml|slash)|t(?:imes|horn)|U(?:grave|acute|circ|uml)|Yacute|THORN|e(?:grave|acute|circ|uml|th)
            |\#\d{4}
            |\#x\h{4}
          );
        /x)
      elsif c = @src.scan(/\\\W/)
        c = CGI.escape_html c[1]
      elsif c = @src.scan(/\n/)
        # TODO make it a symbol, and removable for some circumstances
        c = '<br>'
      elsif c = @src.scan(/./)
        c = CGI.escape_html c
      else
        return
      end

      if emit
        @out << c
        true
      else
        c
      end
    end

    # {...}
    def scan_recursive_braces
      s = @src.scan(/
        (?<braces> \{
          ([^\{]+ | \g<braces>)*  # recursive rule
        \})
      /x)
      s[1...-1]
    end

    # (...)
    def scan_lexical_parens
      s = @src.scan(/
        \(
          (?: \\ [\\\)] | [^\)] )+  # lexical rule
        \)
      /x)
      s[1...-1].gsub(/\\[\)\\]/){|x| x[1]}
    end
  end
end
