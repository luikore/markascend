module Markascend
  LineUnit = Struct.new :line, :block, :linenum
  # process a line with (maybe) a followed up indented block
  class LineUnit
    class << self
      attr_accessor :parsers
    end
    LineUnit.parsers = [
      :parse_code,
      :parse_math,
      :parse_auto_link,
      :parse_escape,
      :parse_macro,
      # link/bold/italic can contain char
      # but link need not interpolate with bold or italic, seems too rare cased
      :parse_link,
      # bold and italic can interpolate each other
      :parse_bold_italic,
      :parse_char
    ]

    def parse
      # block code
      if /^\|\ *(?!\d)(?<lang>\w+)\ *$/ =~ line
        # TODO hilite class
        return "<code class='code-#{lang}'>#{(CGI.escape_html block) if block}</code>"
      end

      @out = []
      @src = StringScanner.new line
      while LineUnit.parsers.any?{|p| send p}
      end
      @out.join
    end

    def parse_code
      if (s = @src.scan /\`(\\[\\\`]|[^`])*\`/)
        # TODO assign inline color class
        @out << '<code>'
        @out << (CGI.escape_html s[1...-1].gsub(/\\([\\\`])/, '\1'))
        @out << '</code>'
        true
      end
    end

    def parse_math
      if (s = @src.scan /\$(?:\\\$|[^$])*\$/)
        @out << '<code class="math">'
        @out << (CGI.escape_html s[1...-1])
        @out << '</code>'
        true
      end
    end

    def parse_auto_link
      # TODO make protocol configurable
      if (s = @src.scan /(https|http|ftp|mailto)\:\/\/\S+/)
        s.gsub! /"/, '\\"'
        @out << '<a href="#{s}">'
        @out << (CGI.escape_html s)
        @out << '</a>'
        true
      end
    end

    def parse_escape
      if (s = @src.scan /\\\W/)
        @out << CGI.escape_html(s[1])
        true
      end
    end

    def parse_macro
      return unless macro = @src.scan(/\\(?!\d)\w+/)
      macro = macro[1..-1]
      if s = @src.scan(/
          \(
            (?: \\ [\\\)] | [^\)] )+  # lexical rule
          \)
        /x)
        block = s[(macro.size + 2)...-1].gsub(/\\[\)\\]/){|x| x[1]}
      elsif s = @src.scan(/
          (?<braces> \{
            ([^\{]+ | \g<braces>)*  # recursive rule
          \})
        /x)
        block = s[(macro.size + 2)...-1]
      else
        block = self.block
      end
      @out << Macro.new(macro, block).parse
      true
    end

    def parse_link
      # TODO
    end

    def parse_bold_italic emit=true
      pos = @src.pos
      if s = @src.scan(/\*\*/)
        term = /\*\*/
        out = ['<b>']
        out_end = '</b>'
      elsif s = @src.scan(/\*/)
        term = /\*/
        out = ['<i>']
        out_end = '</i>'
      else
        return
      end

      loop do
        if res = @src.scan(/\\[\\\*]/)
          out << res[1]
        elsif @src.scan(term)
          out << out_end
          break
        elsif res = parse_bold_italic(false)
          out << res
        elsif res = parse_char(false)
          out << res
        else
          # failed
          @src.pos = pos
          return
        end
      end

      if emit
        @out << out.join
        true
      else
        out.join
      end
    end

    def parse_char emit=true
      # entity list generated by:
      # ruby -rregexp_optimized_union -e'puts Regexp.optimized_union($stdin.read.scan(/(?<=ENTITY )\w+/)).source' < tools/html4_entities.dtd
      # dtd from http://www.w3.org/TR/html4/sgml/entities.html
      if c = @src.scan(/
          &(?:
            n(?:bsp|ot|tilde)|i(?:excl|quest|grave|acute|circ|uml)|c(?:e(?:nt|dil)|urren|opy|cedil)|p(?:ound|lusmn|ara)|y(?:en|acute|uml)|brvbar|s(?:ect|hy|up[123]|zlig)|u(?:ml|grave|acute|circ|uml)|o(?:rd[fm]|grave|acute|circ|tilde|uml|slash)|laquo|r(?:eg|aquo)|m(?:acr|i(?:cro|ddot))|d(?:eg|ivide)|a(?:c(?:ute|irc)|grave|acute|tilde|uml|ring|elig)|frac(?:1[24]|34)|A(?:grave|acute|circ|tilde|uml|ring|Elig)|Ccedil|E(?:grave|acute|circ|uml|TH)|I(?:grave|acute|circ|uml)|Ntilde|O(?:grave|acute|circ|tilde|uml|slash)|t(?:imes|horn)|U(?:grave|acute|circ|uml)|Yacute|THORN|e(?:grave|acute|circ|uml|th)
            |\#\d{4}
            |\#x\h{4}
          );
        /x)
      elsif c = @src.scan(/\n/)
        c = '<br>'
      elsif c = @src.scan(/./)
        c = CGI.escape_html c
      else
        return
      end

      if emit
        @out << c
        true
      else
        c
      end
    end
  end
end
